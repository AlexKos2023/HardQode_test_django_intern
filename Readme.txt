Проекта включает в себя три модели Product, Lesson и Group.
1. Модель Product:
   - Поля:
     - creator: ForeignKey на модель User, указывающий на пользователя, создавшего продукт.
     - name: CharField для хранения названия продукта.
     - start_date: DateTimeField для хранения даты начала продаж продукта.
     - cost: DecimalField для хранения стоимости продукта.
   - Методы:
     - has_access(self, user): Метод, который проверяет доступ пользователя к продукту по 2 условиям:
1.1 Проверяется, что пользователь состоит в группе, связанной с продуктом,. Это делается с помощью фильтрации групп пользователя по полю product, которое является внешним ключом на модель Product. Если хотя бы одна из групп пользователя связана с данным продуктом, то метод вернет True.
1.2 Проверяется, что дата начала продукта (start_date) меньше текущей даты и времени (timezone.now()). Это означает, что пользователь имеет доступ к продукту только если дата начала продукта уже наступила.
Если оба условия выполнены, метод вернет True, что означает, что у пользователя есть доступ к продукту.

2. Модель Lesson:
   - Поля:
     - product: ForeignKey на модель Product, указывающий на продукт, к которому относится урок.
     - title: CharField для хранения заголовка урока.
     - video_link: URLField для хранения ссылки на видео урока.

3. Модель Group:
   - Поля:
     - product: ForeignKey на модель Product, указывающий на продукт, к которому относится группа.
     - name: CharField для хранения названия группы.
     - min_users: PositiveSmallIntegerField для хранения минимального количества пользователей в группе.
     - max_users: PositiveSmallIntegerField для хранения максимального количества пользователей в группе.
     - users: ManyToManyField на модель User, связывающий пользователей с группой.

Таким образом, в базе данных созданы следующие таблицы:
- Таблица Product с полями: id (Primary Key), creator_id, name, start_date, cost.
- Таблица Lesson с полями: id (Primary Key), product_id, title, video_link.
- Таблица Group с полями: id (Primary Key), product_id, name, min_users, max_users.
- Таблица для связи многие ко многим между таблицами Group и User.

Связи между таблицами:
- Модель Lesson связана с моделью Product через поле product.
- Модель Group связана с моделью Product через поле product.
- Модель Group связана с моделью User через поле users.


4. Распределение пользователей по группам при доступе к продукту. В signals.py определен сигнал post_save, который срабатывает после сохранения объекта модели Product. Когда объект Product сохраняется, этот сигнал будет вызывать функцию handle_product_access, которая проверяет, был ли создан новый объект или обновлен существующий.

4.1. При создании нового объекта Product (если created=True), вызывается функция access_product из модуля utils, передавая ей аргументы instance.product и instance.user и access_product распределяет по группам.
4.3. Алгоритм распределения пользователей по группам:
    4.3.1. Проверяем, начался ли продукт. Если да, переходим к следующему шагу, иначе ничего не делаем.
    4.3.2. Пересчитываем количество пользователей в каждой группе и определяем среднее количество пользователей на группу.
    4.3.3. Рассчитываем оставшееся количество пользователей, которые нужно распределить.
    4.3.4. Проходим по каждой группе и добавляем пользователя в группу, если выполняются следующие условия:
       - Количество пользователей в группе меньше максимального значения.
       - Есть оставшиеся пользователи для распределения.

5. Метод lessons_count в ProductSerializer используется для вычисления количества уроков, связанных с конкретным продуктом.
  
6. Маршруты:
    6.1. path('products/<int:product_id>/lessons/', ProductLessonsView.as_view(), name='product_lessons') определяет шаблон URL для обработки запросов к урокам конкретного продукта. 
    6.2. path('available_products/', AvailableProductsView.as_view(), name='available_products') определяет шаблон URL для отображения доступных продуктов.
    6.3. path('user_products/<int:product_id>/lessons/', UserProductLessonsView.as_view(), name='user_product_lessons') определяет шаблон URL для отображения уроков конкретного продукта для пользователя.

7. Представления:
    7.1. ProductLessonsView(APIView): Представление для получения уроков конкретного продукта. Метод get выполняет следующие действия:
   - Проверяет существование продукта по переданному идентификатору.
   - Проверяет доступ пользователя к продукту.
   - Распределяет пользователя по группам.
   - Получает уроки для данного продукта и сериализует их с помощью LessonSerializer.
    7.2. UserProductLessonsView(APIView): Представление для получения уроков конкретного продукта для пользователя. Метод get выполняет аналогичные действия, что и в предыдущем представлении.
    7.3. AvailableProductsView(APIView): Представление для получения списка всех продуктов. Метод get получает все продукты из базы данных и сериализует их с помощью ProductSerializer.

8.Административная панель не определена в URL.
Код имеющийся внутри автоматически регистрирует все модели из приложения 'for_test' в административной панели, что делает их доступными для просмотра, создания, обновления и удаления через интерфейс администратора.







Справка по выполняемому заданию:
Перед тем, как приступить к выполнению задания, советуем изучить документацию, которая поможет в выполнении заданий:

1. https://docs.djangoproject.com/en/4.2/intro/tutorial01/
2. https://docs.djangoproject.com/en/4.2/topics/db/models/
3. https://docs.djangoproject.com/en/4.2/topics/db/queries/
4. https://docs.djangoproject.com/en/4.2/ref/models/querysets/
5. https://docs.djangoproject.com/en/4.2/topics/signals/
6. https://www.django-rest-framework.org/tutorial/quickstart/
7. https://www.django-rest-framework.org/api-guide/viewsets/
8. https://www.django-rest-framework.org/api-guide/serializers/

# Построение системы для обучения

Суть задания заключается в проверке знаний построения связей в БД и умение правильно строить запросы без ошибок N+1.

### **Построение архитектуры(6 баллов)**

В этом задании у нас есть три бизнес-задачи на хранение:

1. Создать сущность продукта. У продукта должен быть создатель этого продукта(автор/преподаватель). Название продукта, дата и время старта, стоимость **(1 балл)**
2. Определить, каким образом мы будем понимать, что у пользователя(клиент/студент) есть доступ к продукту. **(2 балл)**
3. Создать сущность урока. Урок может принадлежать только одному продукту.. В уроке должна быть базовая информация: название, ссылка на видео. **(1 балл)**
4. Создать сущность группы. По каждому продукту есть несколько групп пользователей, которые занимаются в этом продукте. Минимальное и максимальное количество юзеров в группе задается внутри продукта. Группа содержит следующую информацию: ученики, которые состоят в группе, название группы, принадлежность группы к продукту **(2 балла)**

### **Написание запросов и реализация логики распределения(11 баллов)**

В этом пункте потребуется использовать выполненную вами в прошлом задании архитектуру:

1. При получении доступа к продукту, распределять пользователя в группу. Если продукт ещё не начался, то можно пересобрать группы так, чтобы везде было примерно одинаковое количество участников.
    
    По-умолчанию алгоритм распределения должен работать заполняя до максимального значения **(5 баллов)**.
    
    **+3 балла** дается за реализацию алгоритма распределения по группам так, чтобы в каждой группе количество участников не отличалось больше, чем на 1. При этом, минимальные и максимальные значения участников в группе должны быть учтены.
    
2. Реализовать API на список продуктов, доступных для покупки, которое бы включало в себя основную информацию о продукте и количество уроков, которые принадлежат продукту. **(2 балла)**
3. Реализовать API с выведением списка уроков по конкретному продукту к которому пользователь имеет доступ. **(1 балл)**.

### **Результат выполнения:**

1. Выполненная архитектура на базе данных SQLite с использованием Django.
2. Реализованные API на базе готовой архитектуры.






